{"version":3,"file":"static/js/app.eb41bf8f4763330b6ec3.js","sources":["webpack:///./src/vendor/prism.js"],"sourcesContent":["/* eslint-disable */\n/* http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript+jsx+sass */\nvar _self =\n  typeof window !== 'undefined'\n    ? window // if in browser\n    : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n      ? self // if in worker\n      : {} // if in node js\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function() {\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-(\\w+)\\b/i\n  var uniqueId = 0\n\n  var _ = (_self.Prism = {\n    manual: _self.Prism && _self.Prism.manual,\n    util: {\n      encode: function(tokens) {\n        if (tokens instanceof Token) {\n          return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias)\n        } else if (_.util.type(tokens) === 'Array') {\n          return tokens.map(_.util.encode)\n        } else {\n          return tokens\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/\\u00a0/g, ' ')\n        }\n      },\n\n      type: function(o) {\n        return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1]\n      },\n\n      objId: function(obj) {\n        if (!obj['__id']) {\n          Object.defineProperty(obj, '__id', { value: ++uniqueId })\n        }\n        return obj['__id']\n      },\n\n      // Deep clone a language definition (e.g. to extend it)\n      clone: function(o) {\n        var type = _.util.type(o)\n\n        switch (type) {\n          case 'Object':\n            var clone = {}\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = _.util.clone(o[key])\n              }\n            }\n\n            return clone\n\n          case 'Array':\n            // Check for existence for IE8\n            return (\n              o.map &&\n              o.map(function(v) {\n                return _.util.clone(v)\n              })\n            )\n        }\n\n        return o\n      },\n    },\n\n    languages: {\n      extend: function(id, redef) {\n        var lang = _.util.clone(_.languages[id])\n\n        for (var key in redef) {\n          lang[key] = redef[key]\n        }\n\n        return lang\n      },\n\n      /**\n       * Insert a token before another token in a language literal\n       * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n       * we cannot just provide an object, we need anobject and a key.\n       * @param inside The key (or language id) of the parent\n       * @param before The key to insert before. If not provided, the function appends instead.\n       * @param insert Object with the key/value pairs to insert\n       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n       */\n      insertBefore: function(inside, before, insert, root) {\n        root = root || _.languages\n        var grammar = root[inside]\n\n        if (arguments.length == 2) {\n          insert = arguments[1]\n\n          for (var newToken in insert) {\n            if (insert.hasOwnProperty(newToken)) {\n              grammar[newToken] = insert[newToken]\n            }\n          }\n\n          return grammar\n        }\n\n        var ret = {}\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken]\n                }\n              }\n            }\n\n            ret[token] = grammar[token]\n          }\n        }\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function(key, value) {\n          if (value === root[inside] && key != inside) {\n            this[key] = ret\n          }\n        })\n\n        return (root[inside] = ret)\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function(o, callback, type, visited) {\n        visited = visited || {}\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i)\n\n            if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n              visited[_.util.objId(o[i])] = true\n              _.languages.DFS(o[i], callback, null, visited)\n            } else if (\n              _.util.type(o[i]) === 'Array' &&\n              !visited[_.util.objId(o[i])]\n            ) {\n              visited[_.util.objId(o[i])] = true\n              _.languages.DFS(o[i], callback, i, visited)\n            }\n          }\n        }\n      },\n    },\n    plugins: {},\n\n    highlightAll: function(async, callback) {\n      var env = {\n        callback: callback,\n        selector:\n          'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code',\n      }\n\n      _.hooks.run('before-highlightall', env)\n\n      var elements = env.elements || document.querySelectorAll(env.selector)\n\n      for (var i = 0, element; (element = elements[i++]); ) {\n        _.highlightElement(element, async === true, env.callback)\n      }\n    },\n\n    highlightElement: function(element, async, callback) {\n      // Find language\n      var language,\n        grammar,\n        parent = element\n\n      while (parent && !lang.test(parent.className)) {\n        parent = parent.parentNode\n      }\n\n      if (parent) {\n        language = (parent.className.match(lang) || [, ''])[1].toLowerCase()\n        grammar = _.languages[language]\n      }\n\n      // Set language on the element, if not present\n      element.className =\n        element.className.replace(lang, '').replace(/\\s+/g, ' ') +\n        ' language-' +\n        language\n\n      // Set language on the parent, for styling\n      parent = element.parentNode\n\n      if (/pre/i.test(parent.nodeName)) {\n        parent.className =\n          parent.className.replace(lang, '').replace(/\\s+/g, ' ') +\n          ' language-' +\n          language\n      }\n\n      var code = element.textContent\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code,\n      }\n\n      _.hooks.run('before-sanity-check', env)\n\n      if (!env.code || !env.grammar) {\n        if (env.code) {\n          _.hooks.run('before-highlight', env)\n          env.element.textContent = env.code\n          _.hooks.run('after-highlight', env)\n        }\n        _.hooks.run('complete', env)\n        return\n      }\n\n      _.hooks.run('before-highlight', env)\n\n      if (async && _self.Worker) {\n        var worker = new Worker(_.filename)\n\n        worker.onmessage = function(evt) {\n          env.highlightedCode = evt.data\n\n          _.hooks.run('before-insert', env)\n\n          env.element.innerHTML = env.highlightedCode\n\n          callback && callback.call(env.element)\n          _.hooks.run('after-highlight', env)\n          _.hooks.run('complete', env)\n        }\n\n        worker.postMessage(\n          JSON.stringify({\n            language: env.language,\n            code: env.code,\n            immediateClose: true,\n          }),\n        )\n      } else {\n        env.highlightedCode = _.highlight(env.code, env.grammar, env.language)\n\n        _.hooks.run('before-insert', env)\n\n        env.element.innerHTML = env.highlightedCode\n\n        callback && callback.call(element)\n\n        _.hooks.run('after-highlight', env)\n        _.hooks.run('complete', env)\n      }\n    },\n\n    highlight: function(text, grammar, language) {\n      var tokens = _.tokenize(text, grammar)\n      return Token.stringify(_.util.encode(tokens), language)\n    },\n\n    matchGrammar: function(\n      text,\n      strarr,\n      grammar,\n      index,\n      startPos,\n      oneshot,\n      target,\n    ) {\n      var Token = _.Token\n\n      for (var token in grammar) {\n        if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n          continue\n        }\n\n        if (token == target) {\n          return\n        }\n\n        var patterns = grammar[token]\n        patterns = _.util.type(patterns) === 'Array' ? patterns : [patterns]\n\n        for (var j = 0; j < patterns.length; ++j) {\n          var pattern = patterns[j],\n            inside = pattern.inside,\n            lookbehind = !!pattern.lookbehind,\n            greedy = !!pattern.greedy,\n            lookbehindLength = 0,\n            alias = pattern.alias\n\n          if (greedy && !pattern.pattern.global) {\n            // Without the global flag, lastIndex won't work\n            var flags = pattern.pattern.toString().match(/[imuy]*$/)[0]\n            pattern.pattern = RegExp(pattern.pattern.source, flags + 'g')\n          }\n\n          pattern = pattern.pattern || pattern\n\n          // Donâ€™t cache length as it changes during the loop\n          for (\n            var i = index, pos = startPos;\n            i < strarr.length;\n            pos += strarr[i].length, ++i\n          ) {\n            var str = strarr[i]\n\n            if (strarr.length > text.length) {\n              // Something went terribly wrong, ABORT, ABORT!\n              return\n            }\n\n            if (str instanceof Token) {\n              continue\n            }\n\n            pattern.lastIndex = 0\n\n            var match = pattern.exec(str),\n              delNum = 1\n\n            // Greedy patterns can override/remove up to two previously matched tokens\n            if (!match && greedy && i != strarr.length - 1) {\n              pattern.lastIndex = pos\n              match = pattern.exec(text)\n              if (!match) {\n                break\n              }\n\n              var from = match.index + (lookbehind ? match[1].length : 0),\n                to = match.index + match[0].length,\n                k = i,\n                p = pos\n\n              for (\n                var len = strarr.length;\n                k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy));\n                ++k\n              ) {\n                p += strarr[k].length\n                // Move the index i to the element in strarr that is closest to from\n                if (from >= p) {\n                  ++i\n                  pos = p\n                }\n              }\n\n              /*\n\t\t\t\t\t\t * If strarr[i] is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\t * If strarr[k - 1] is greedy we are in conflict with another greedy pattern\n\t\t\t\t\t\t */\n              if (strarr[i] instanceof Token || strarr[k - 1].greedy) {\n                continue\n              }\n\n              // Number of tokens to delete and replace with the new match\n              delNum = k - i\n              str = text.slice(pos, p)\n              match.index -= pos\n            }\n\n            if (!match) {\n              if (oneshot) {\n                break\n              }\n\n              continue\n            }\n\n            if (lookbehind) {\n              lookbehindLength = match[1].length\n            }\n\n            var from = match.index + lookbehindLength,\n              match = match[0].slice(lookbehindLength),\n              to = from + match.length,\n              before = str.slice(0, from),\n              after = str.slice(to)\n\n            var args = [i, delNum]\n\n            if (before) {\n              ++i\n              pos += before.length\n              args.push(before)\n            }\n\n            var wrapped = new Token(\n              token,\n              inside ? _.tokenize(match, inside) : match,\n              alias,\n              match,\n              greedy,\n            )\n\n            args.push(wrapped)\n\n            if (after) {\n              args.push(after)\n            }\n\n            Array.prototype.splice.apply(strarr, args)\n\n            if (delNum != 1)\n              _.matchGrammar(text, strarr, grammar, i, pos, true, token)\n\n            if (oneshot) break\n          }\n        }\n      }\n    },\n\n    tokenize: function(text, grammar, language) {\n      var strarr = [text]\n\n      var rest = grammar.rest\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token]\n        }\n\n        delete grammar.rest\n      }\n\n      _.matchGrammar(text, strarr, grammar, 0, 0, false)\n\n      return strarr\n    },\n\n    hooks: {\n      all: {},\n\n      add: function(name, callback) {\n        var hooks = _.hooks.all\n\n        hooks[name] = hooks[name] || []\n\n        hooks[name].push(callback)\n      },\n\n      run: function(name, env) {\n        var callbacks = _.hooks.all[name]\n\n        if (!callbacks || !callbacks.length) {\n          return\n        }\n\n        for (var i = 0, callback; (callback = callbacks[i++]); ) {\n          callback(env)\n        }\n      },\n    },\n  })\n\n  var Token = (_.Token = function(type, content, alias, matchedStr, greedy) {\n    this.type = type\n    this.content = content\n    this.alias = alias\n    // Copy of the full string this token was created from\n    this.length = (matchedStr || '').length | 0\n    this.greedy = !!greedy\n  })\n\n  Token.stringify = function(o, language, parent) {\n    if (typeof o == 'string') {\n      return o\n    }\n\n    if (_.util.type(o) === 'Array') {\n      return o\n        .map(function(element) {\n          return Token.stringify(element, language, o)\n        })\n        .join('')\n    }\n\n    var env = {\n      type: o.type,\n      content: Token.stringify(o.content, language, parent),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n      parent: parent,\n    }\n\n    if (env.type == 'comment') {\n      env.attributes['spellcheck'] = 'true'\n    }\n\n    if (o.alias) {\n      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias]\n      Array.prototype.push.apply(env.classes, aliases)\n    }\n\n    _.hooks.run('wrap', env)\n\n    var attributes = Object.keys(env.attributes)\n      .map(function(name) {\n        return (\n          name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"'\n        )\n      })\n      .join(' ')\n\n    return (\n      '<' +\n      env.tag +\n      ' class=\"' +\n      env.classes.join(' ') +\n      '\"' +\n      (attributes ? ' ' + attributes : '') +\n      '>' +\n      env.content +\n      '</' +\n      env.tag +\n      '>'\n    )\n  }\n\n  if (!_self.document) {\n    if (!_self.addEventListener) {\n      // in Node.js\n      return _self.Prism\n    }\n    // In worker\n    _self.addEventListener(\n      'message',\n      function(evt) {\n        var message = JSON.parse(evt.data),\n          lang = message.language,\n          code = message.code,\n          immediateClose = message.immediateClose\n\n        _self.postMessage(_.highlight(code, _.languages[lang], lang))\n        if (immediateClose) {\n          _self.close()\n        }\n      },\n      false,\n    )\n\n    return _self.Prism\n  }\n\n  //Get current script and highlight\n  var script =\n    document.currentScript ||\n    [].slice.call(document.getElementsByTagName('script')).pop()\n\n  if (script) {\n    _.filename = script.src\n\n    if (\n      document.addEventListener &&\n      !_.manual &&\n      !script.hasAttribute('data-manual')\n    ) {\n      if (document.readyState !== 'loading') {\n        if (window.requestAnimationFrame) {\n          window.requestAnimationFrame(_.highlightAll)\n        } else {\n          window.setTimeout(_.highlightAll, 16)\n        }\n      } else {\n        document.addEventListener('DOMContentLoaded', _.highlightAll)\n      }\n    }\n  }\n\n  return _self.Prism\n})()\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Prism\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n  global.Prism = Prism\n}\nPrism.languages.markup = {\n  comment: /<!--[\\s\\S]*?-->/,\n  prolog: /<\\?[\\s\\S]+?\\?>/,\n  doctype: /<!DOCTYPE[\\s\\S]+?>/i,\n  cdata: /<!\\[CDATA\\[[\\s\\S]*?]]>/i,\n  tag: {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\s\\S])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[^\\s>\\/]+/i,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[^\\s>\\/:]+:/,\n        },\n      },\n      'attr-value': {\n        pattern: /=(?:('|\")[\\s\\S]*?(\\1)|[^\\s>]+)/i,\n        inside: {\n          punctuation: /[=>\"']/,\n        },\n      },\n      punctuation: /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          namespace: /^[^\\s>\\/:]+:/,\n        },\n      },\n    },\n  },\n  entity: /&#?[\\da-z]{1,8};/i,\n}\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n  Prism.languages.markup['entity']\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&')\n  }\n})\n\nPrism.languages.xml = Prism.languages.markup\nPrism.languages.html = Prism.languages.markup\nPrism.languages.mathml = Prism.languages.markup\nPrism.languages.svg = Prism.languages.markup\n\nPrism.languages.css = {\n  comment: /\\/\\*[\\s\\S]*?\\*\\//,\n  atrule: {\n    pattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n    inside: {\n      rule: /@[\\w-]+/,\n      // See rest below\n    },\n  },\n  url: /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n  selector: /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n  string: {\n    pattern: /(\"|')(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true,\n  },\n  property: /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n  important: /\\B!important\\b/i,\n  function: /[-a-z0-9]+(?=\\()/i,\n  punctuation: /[(){};:]/,\n}\n\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css)\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    style: {\n      pattern: /(<style[\\s\\S]*?>)[\\s\\S]*?(?=<\\/style>)/i,\n      lookbehind: true,\n      inside: Prism.languages.css,\n      alias: 'language-css',\n    },\n  })\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-value',\n    {\n      'style-attr': {\n        pattern: /\\s*style=(\"|').*?\\1/i,\n        inside: {\n          'attr-name': {\n            pattern: /^\\s*style/i,\n            inside: Prism.languages.markup.tag.inside,\n          },\n          punctuation: /^\\s*=\\s*['\"]|['\"]\\s*$/,\n          'attr-value': {\n            pattern: /.+/i,\n            inside: Prism.languages.css,\n          },\n        },\n        alias: 'language-css',\n      },\n    },\n    Prism.languages.markup.tag,\n  )\n}\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true,\n    },\n  ],\n  string: {\n    pattern: /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true,\n  },\n  'class-name': {\n    pattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      punctuation: /(\\.|\\\\)/,\n    },\n  },\n  keyword: /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  boolean: /\\b(true|false)\\b/,\n  function: /[a-z0-9_]+(?=\\()/i,\n  number: /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n  operator: /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n  punctuation: /[{}[\\];(),.:]/,\n}\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  keyword: /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n  number: /\\b-?(0[xX][\\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  function: /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i,\n  operator: /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/,\n})\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern: /(^|[^/])\\/(?!\\/)(\\[[^\\]\\r\\n]+]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n    lookbehind: true,\n    greedy: true,\n  },\n})\n\nPrism.languages.insertBefore('javascript', 'string', {\n  'template-string': {\n    pattern: /`(?:\\\\\\\\|\\\\?[^\\\\])*?`/,\n    greedy: true,\n    inside: {\n      interpolation: {\n        pattern: /\\$\\{[^}]+\\}/,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation',\n          },\n          rest: Prism.languages.javascript,\n        },\n      },\n      string: /[\\s\\S]+/,\n    },\n  },\n})\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    script: {\n      pattern: /(<script[\\s\\S]*?>)[\\s\\S]*?(?=<\\/script>)/i,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n      alias: 'language-javascript',\n    },\n  })\n}\n\nPrism.languages.js = Prism.languages.javascript\n;(function(Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript)\n\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n  Prism.languages.jsx.tag.pattern = /<\\/?[\\w\\.:-]+\\s*(?:\\s+(?:[\\w\\.:-]+(?:=(?:(\"|')(\\\\?[\\s\\S])*?\\1|[^\\s'\">=]+|(\\{[\\s\\S]*?\\})))?|\\{\\.{3}\\w+\\}))*\\s*\\/?>/i\n\n  Prism.languages.jsx.tag.inside[\n    'attr-value'\n  ].pattern = /=(?!\\{)(?:('|\")[\\s\\S]*?(\\1)|[^\\s>]+)/i\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-name',\n    {\n      spread: {\n        pattern: /\\{\\.{3}\\w+\\}/,\n        inside: {\n          punctuation: /\\{|\\}|\\./,\n          'attr-value': /\\w+/,\n        },\n      },\n    },\n    Prism.languages.jsx.tag,\n  )\n\n  var jsxExpression = Prism.util.clone(Prism.languages.jsx)\n\n  delete jsxExpression.punctuation\n\n  jsxExpression = Prism.languages.insertBefore(\n    'jsx',\n    'operator',\n    {\n      punctuation: /=(?={)|[{}[\\];(),.:]/,\n    },\n    { jsx: jsxExpression },\n  )\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-value',\n    {\n      script: {\n        // Allow for one level of nesting\n        pattern: /=(\\{(?:\\{[^}]*\\}|[^}])+\\})/i,\n        inside: jsxExpression,\n        alias: 'language-javascript',\n      },\n    },\n    Prism.languages.jsx.tag,\n  )\n})(Prism)\n;(function(Prism) {\n  Prism.languages.sass = Prism.languages.extend('css', {\n    // Sass comments don't need to be closed, only indented\n    comment: {\n      pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t]+.+)*/m,\n      lookbehind: true,\n    },\n  })\n\n  Prism.languages.insertBefore('sass', 'atrule', {\n    // We want to consume the whole line\n    'atrule-line': {\n      // Includes support for = and + shortcuts\n      pattern: /^(?:[ \\t]*)[@+=].+/m,\n      inside: {\n        atrule: /(?:@[\\w-]+|[+=])/m,\n      },\n    },\n  })\n  delete Prism.languages.sass.atrule\n\n  var variable = /((\\$[-_\\w]+)|(#\\{\\$[-_\\w]+\\}))/i\n  var operator = [\n    /[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|or|not)\\b/,\n    {\n      pattern: /(\\s+)-(?=\\s)/,\n      lookbehind: true,\n    },\n  ]\n\n  Prism.languages.insertBefore('sass', 'property', {\n    // We want to consume the whole line\n    'variable-line': {\n      pattern: /^[ \\t]*\\$.+/m,\n      inside: {\n        punctuation: /:/,\n        variable: variable,\n        operator: operator,\n      },\n    },\n    // We want to consume the whole line\n    'property-line': {\n      pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s]+.*)/m,\n      inside: {\n        property: [\n          /[^:\\s]+(?=\\s*:)/,\n          {\n            pattern: /(:)[^:\\s]+/,\n            lookbehind: true,\n          },\n        ],\n        punctuation: /:/,\n        variable: variable,\n        operator: operator,\n        important: Prism.languages.sass.important,\n      },\n    },\n  })\n  delete Prism.languages.sass.property\n  delete Prism.languages.sass.important\n\n  // Now that whole lines for other patterns are consumed,\n  // what's left should be selectors\n  delete Prism.languages.sass.selector\n  Prism.languages.insertBefore('sass', 'punctuation', {\n    selector: {\n      pattern: /([ \\t]*)\\S(?:,?[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,?[^,\\r\\n]+)*)*/,\n      lookbehind: true,\n    },\n  })\n})(Prism)\n\n\n\n// WEBPACK FOOTER //\n// ./src/vendor/prism.js"],"mappings":"AAAA","sourceRoot":""}